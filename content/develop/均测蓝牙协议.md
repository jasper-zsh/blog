---
title: 均测库仑计蓝牙协议分析
author: JasperZ
section: develop
tags:
  - 玩车
  - 嵌入式开发
date: 2025-08-14
share: true
layout: post
---


# 综述

根据`uni.getBLEDeviceServices`选择服务的行为分析得知协议使用了倒数第二个服务（很粗暴）
`monitor`方法用于发起数据监听，搜索`uni.onBLECharacteristicValueChange`可知处理监听数据的回调方法为`rxd`

Characteristic的用途如下表：

| 序号  | UUID | 用途   |
| --- | ---- | ---- |
| 0   | fff1 | 接收数据 |
| 1   | fff2 | 发送指令 |

# 数据处理
整个协议中的数字都是将HEX直接当作十进制数字文本进行解析得来的，后文不再补充描述
## 一些特殊的包
- 0x48: 正在升级固件
- 0x4848: 未知，怀疑是升级完成
- 0x44: `t.online = true`应该是标识连接状态
- 0x45: 升级失败
- 0x43: `true1`自增，这是个计数器，用途未知
## 数据包
正常的数据包以0xBB或0xAA开头，0xEE结尾；
数据包的处理逻辑比较暴力，包类型是用包含进行判断的，共分为3种类型的包：
- 0xA0: 图表数据对象，由`historyStrToObj`函数处理
- 0xF4: 图表数据时间，由`historyTimeStrToObj`函数处理
- 其他情况视为数据对象，由`strToObj`函数处理
### 数据对象
数据流的组成方式不是正常的二进制流，所以无需考虑字节序的问题，但反编译得来的处理逻辑仍是接近LE的形态（从右至左处理），单字节HEX形式中纯数字的情况用于表示十进制整数（按十进制字符串直接转换），其余情况表示数据字段，各字段含义如下表：

| 字段   | 含义                                       |
| ---- | ---------------------------------------- |
| 0xF6 | 密码                                       |
| 0xE0 | 数据加载中，发送0x9AA9可以继续获取数据，否则发送0x9AE0以开始加载数据 |
| 0xD2 | 剩余电量，6为数字格式为DDD.DDD                      |
| 0xB0 | 总电量，4位数字格式DDD.D                          |
| 0xF9 | 低电量告警百分比，2位数字                            |
| 0xF7 | 待确认，温度单位                                 |
| 0xD9 | 温度，前两位是单位，后两位是温度整数                       |
| 0xC0 | 电压，4位数字格式DD.DD                           |
| 0xC1 | 电流，4位数字格式DD.DD                           |
| 0xD8 | 功率，单位W，6位数字格式为DDDD.DD                    |
| 0xC4 | 地址匹配，2位数字                                |
| 0xB7 | 继电器类型，0为常开，1为常闭                          |
| 0xD5 | 数据记录数量                                   |
| 0xF1 | 数据记录开关，0为开启，1为关闭                         |
| 0xF8 | 数据记录时间间隔，2位数字为时间间隔-1                     |

### 数据对象的解析逻辑（strToObj）
从右向左解析，第一字节是字段，后续可直接解析为十进制数字的字节是值

### 指令
发送数据时有一些特殊逻辑，伪代码如下：
```
writeDataValue = data
if writeDataValue == 0x9AA9
	send(0xBB9AA90CEE)
else
	if writeDataValue == 'AR' or 'AD'
		send(strToArrayBuffer(writeDataValue))
	else
		if writeDataValue contains 'b9', 'b8', 'f4', 'f6', 'f2', 'e1'
			send(0xBB + data + 0x0CEE)
		else
			send(checkAdd(writeDataValue))
		
```
显而易见这里有两个特殊指令`AR`和`AD`，他们不是HEX格式；
AR和AD疑似用于固件升级过程，暂时不进行分析；
checkAdd的伪代码如下：
```
checkAdd(data)
	payload = 0xBB + data
	checksum = 0
	for b in payload
		checksum += b
	if password
		checksum = checksumWithPassword(checksum + password)
	else
		checksum = checksum[-1:]
	return payload + checksum + 0xEE
	
```
根据伪代码中的魔数结合checkAdd的实现判断包体最后一个字节是校验位，但实际发送实验发现在没有密码的情况下这一位固定为0C

| 指令                                                  | 含义                               |
| --------------------------------------------------- | -------------------------------- |
| 0x9AE0                                              | 开始加载数据                           |
| 0x9AA9                                              | 获取数据对象                           |
| 0x9AF6                                              | 未知，用于密码交互                        |
| 0x9AF9 + byte + 0xF9                                | 设置低电量提醒阈值百分比                     |
| 0x00A5                                              | 恢复出厂设置                           |
| 0x00A6                                              | 重启设备                             |
| 0x9AC100A4                                          | CurrentClear                     |
| 0x9AC4 + byte + C4                                  | 设置通信地址                           |
| 0x9AC3 + byte + C3                                  | Tpton                            |
| 0x9AC2 + byte + C2                                  | Tptoff                           |
| 0x9AE9 + byte + E9                                  | Min, byte为实际数值*10                |
| 0x9AE7 + byte + E7                                  | LossVoltage, byte为实际数值\*100      |
| 0x9AE8 + byte + E8                                  | FullCurrent, byte为实际数值截断末2位（待确认） |
| 0x9AE6 + byte + E6                                  | FullVoltage, byte为实际数值\*100      |
| 0x9AB7 + byte + B7                                  | 继电器类型, byte为00或01,实际含义待确认        |
| 0x9AE3 + byte + E3                                  | LTP, byte有一套比较复杂的计算逻辑，后附         |
| 0x9AB1 + byte + B1                                  | ETP, byte有一套比较复杂的计算逻辑，后附         |
| 0x9AC9 + byte + C9                                  | OPP, byte为实际数值\*100              |
| 0x9AC8 + byte + C8                                  | NCP, byte为实际数值\*100              |
| 0x9AC7 + byte + C7                                  | OCP, byte为实际数值\*100              |
| 0x9AC6 + byte + C6                                  | LVP, byte为实际数值\*100              |
| 0x9AC5 + byte + C5                                  | OVP, byte为实际数值\*100              |
| 0x9AF1 + byte + F1                                  | 数据记录，00为开启，01为关闭                 |
| 0x9AF8 + byte + F8                                  | 清理数据记录，逻辑待分析                     |
| bytes(yymmdd) + 0xF2 + bytes(hhiiss) + 0xF39AF29AF3 | 设置日期时间                           |
| 0x9AD2 + byte + D2                                  | MBFree, 逻辑待分析                    |
| 0x9AB0 + byte + 0xB0                                | 设置电池容量，byte为实际数值\*10，最大9999      |
| 0x9AE39AB19AF70255E30255B1 + byte + F7              | 设置温度单位，byte逻辑待确认                 |
| 0x9AD99AB4 + byte + B4                              | 设置温度（待确认），byte为实际数值              |
| 0x9AC09AB2 + byte + B2                              | VoltageAlign                     |
| 0x9AC19AB3 + byte + B3                              | CurrentAlign                     |

#### LTP/ETP的计算逻辑