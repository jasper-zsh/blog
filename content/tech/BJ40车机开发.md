---
share: true
title: BJ40车机开发
author: JasperZ
section: tech
tags:
  - BJ40
  - Android
date: 2025-08-14T16:43:00
layout: post
---
# 方控
## adb logcat分析
```
# 导航按键触发日志
06-08 17:58:09.401  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng SrcMngAppOn() reqPackageName = com.tencent.wecar reqMap = null actionName = null
06-08 17:58:09.403  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng startLauncherApp() Begin requestAppPackageName = com.tencent.wecar

# 
```

反编译`SourceMngService.apk`分析逻辑得知方控启动的应用包名配置在`/system/etc/adayo/SourceMng/AdayoSourceMng.conf`文件中，看起来可以用相同的方式修改Media按键切换的应用

# 导航
反编译`NaviService.apk`发现其中同时存在腾讯地图与高德地图两套适配代码，尝试通过修改配置文件的方式更换仪表盘的导航实现。
查看`com.adayo.service.navi.NaviConfig`类发现导航的配置文件在`/etc/adayo/naviconf/naviconf.conf`，同时分析得知高德地图对应的MapType枚举值为`Amap`；
实际测试发现修改该配置文件后并没有效果，观察日志得知AmapNaviListener有正常加载，符合前面分析的结果；所以看起来仪表盘的导航效果另有机制进行处理，继续分析`meterservice.apk`。

实际在开启腾讯导航的同时观察日志发现仪表盘服务打印出了另外的日志：`NaviStatusReceiver`类处理了一些导航状态变化的监听，同时有另外一些日志TAG：`NAVI_STANDARD_NaviManager`看起来涉及到关键逻辑；

先对NaviStatusReceiver进行分析，这个类只处理了一些平台无关的逻辑，所以忽略他，继续分析其他线索；

在`meterservice.apk`中搜索`NaviManager`，只发现了一些服务连接逻辑，猜测这些关键逻辑仍在`NaviService.apk`中，但回去搜索发现这个包里也没有有效的实现，会不会腾讯导航其实是定制版的，这些关键逻辑在导航的包里？检查腾讯导航也没有发现相关的逻辑，目光还是锁定`txAdapterService.apk`这个可疑的包。查找资料发现厂商在编译ROM的时候可以选择只保留优化后的odex/vdex文件，同时移除apk中的dex文件，因此重新回到车机中提取/system/app下的整个应用目录以获取odex/vdex

cdex转dex的工具：[GitHub - fOmey/compact\_dex\_converter: cdex to dex binarys](https://github.com/fOmey/compact_dex_converter)
vdex转cdex的工具：[GitHub - anestisb/vdexExtractor: Tool to decompile & extract Android Dex bytecode from Vdex files](https://github.com/anestisb/vdexExtractor)
这个工具编译会报错，编辑`src/dex_instruction.c`搜索`kMaxVarArgRegs`将这个参数改为指针类型即可编译通过。

反编译后发现`txAdapterService`中只有音乐的处理逻辑，在音乐一节中详细分析。

分析后文得到的`framework.jar`，其中包含了`com.adayo.proxy.navigation.navi.NaviManager`的实现，这个类就是前面提到的`NAVI_STANDARD_NaviManager`这些关键日志的来源。回过头来看`AmapNaviListener`的实现，发现AmapNaviListener.InformationRecv实现了广播的接收，有处理调用NaviManager的逻辑，且在AmapNaviListener构造时注册BroadcastReceiver，从日志来看也正常接收到了来自高德地图的广播，也正常调用了NaviManager服务的方法，看起来这个类的逻辑是完好的。
回过头来分析TxNaviListener的逻辑，腾讯随行并非使用系统广播，而是使用了一套私有SDK来接收导航软件的信息，其逻辑在TxTaesClient中；观察这个类发现了一个特殊点：在其监听到腾讯随行启动时，初始化了一个TxNaviDisplayPresenter类，其中包含了一些显示逻辑，这些逻辑仅在NaviConfig的ProjectName等于`HM6C14A`时有效，而`/etc/adayo/naviconf/naviconf.conf`中的Project正是`HM6C14A`。虽然此时从日志来看TxNaviListener并没有加载，也没有TxNaviDisplayPresenter的日志，但看起来并没有其他可能性了，仿照这里的实现编写一个测试用的显示逻辑试试看；高德地图车机版并没有提供腾讯随行那样与自身通信的SDK，所以如果测试有效的话，可能要单独接入一个地图SDK用来处理显示逻辑。
# 音乐
## 方式1
仪表盘的控制逻辑在`meterservice.apk`中，其中网络音乐的信息控制逻辑在`com.adayo.service.meterservice.control.NetMusicControl`中，搜索相关方法得知在`com.adayo.service.meterservice.managers.ControlManager`中接收ShareDataManager的广播后根据其内容分发至各个类型Control对信息进行处理；仪表盘服务中通过监听ShareData维护了一个当前音频源的状态，在NetMusicControl中会根据音频源是否为TENCENT_WECAR_FLOW来决定是否要处理媒体信息，因此后续要留意如何正确维护或篡改这个状态；
到这里为止仍然没有找到来自安卓系统的广播，继续往下分析。
在`ShareDataManager`中维护了一个ShareDataListener的Map，继续查看`ShareDataListenerImpl`的实现，最终在其基类`IShareDataListenerAIDL.Stub`中找到了一个Binder，其描述符为`com.adayo.proxy.infrastructure.share.aidl.IShareDataListenerAIDL`，这里接收了来自其他进程的数据，并将其转换为Bundle向后分发。
分析`ShareService.apk`，找到了一个配置文件`/etc/shareinfo.json`，这个包看起来像是处理转发的底层服务，没有找到具体业务的信息。
目前高度怀疑爱趣听的广播接收与转发在`txAdapterService.apk`这个包中，但解包发现里面没有dex文件？？？

暂时找不到路径没关系，已经发现了一些关键的方法，接下来刷入Magisk，后续可以考虑用模块来搞！
BJ40的车机找不到进入fastboot的办法，尝试了`adb reboot fastboot`和`adb reboot bootloader`均没有效果，不过没关系，直接使用root权限通过dd强刷即可。
执行以下命令提取boot分区
```shell
dd if=/dev/block/by-name/boot_a of=/sdcard/boot_a.img
dd if=/dev/block/by-name/boot_b of=/sdcard/boot_b.img
```

可能因为没有升级过系统，我提区的ab分区是一样的，盲猜当前使用的是a分区，使用magisk patch之！
patch过后同样使用dd强制刷入
```shell
dd if=patch过的boot.img of=/dev/block/by-name/boot_a
# 刷完重启
reboot
```

重启后进入Magisk查看状态，一次成功！Magisk启动时会提示su与Magisk自带的su有冲突，进入shell把`/xbin/su`移走就可以了（比如改个名字），处理完后发现Zygisk默认是关掉的，可能跟前面的冲突有关系，进入Magisk设置页面将其打开即可。
随后是安装LSPosed，安装过程无惊无险，唯一需要注意的是在车机上开启LSPosed后通知栏并不会显示他的通知，而车机内也找不到拨号软件从而无法按照官网指引进入配置页面；最终在`/data/adb/magisk/services/lspd`中找到`manager.apk`手动安装之，就可以打开LSPosed设置页面了。

## 方式2
分析自带的媒体播放器是怎样传递曲目信息的，反编译`MultiMedia.apk`搜索`sendShareData`发现实际的发送方法在`com.adayo.fpresenter.music.impl.depends.SourceDependImpl`这个类中，可以考虑提取出ShareDataManager的逻辑集成到单独的App中，然后正常监听系统媒体信息的变化来投递ShareData

分析导航时发现音乐的处理方式在`txAdapterService`中，原理是使用爱趣听的SDK监听系统广播，解析媒体状态事件并将其转换为ShareData进行发送，关键逻辑如下：
```
public void saveShareData() {
  
        this.m_Map.put("artist", this.mediaAuthor);
  
        this.m_Map.put("name", this.mediaName);
  
        this.m_Map.put("status", this.mediaState);
  
        this.shareDataManager.sendShareData(61, this.gson.toJson(this.m_Map));
  
    }
```

其中mediaState是个字符串枚举，值为`pause` `stop` `playing`

接下来继续分析`meterservice.apk`探索Source是怎样维护的，在`dealShareInfoData`方法中发现了SourceChangeInfo的dataType为14，且Source唯一的更新来源就是ShareData，尝试到SourceMngService中查找数据的来源，简单搜索14并未找到，不过可能不重要，理论上只要在发送媒体信息时一并发送dataType为14的ShareData来更新Source即可；实现方式已经确定，准备开干！

分析`com.adayo.proxy.infrastructure.share.ShareDataManager`的反编译代码发现这个类调用的服务可能被编译到定制的framework.jar中了，从车机中拖回来加入工程，方法参考[高版本 Android Studio 集成 framework.jar - 掘金](https://juejin.cn/post/7276294701522255909)
提取framework.jar的过程也比较波折，`/system/framework/framework.jar`里面不包含dex文件，参考前文，厂商在编译过程中也将dex转化为了vdex进行存储，参照前文方法将`/system/framework/arm64/boot-framework.vdex`反编译为dex，使用`dex2jar`转换为jar包，合并打包为framework.jar进行使用。
监听系统的媒体信息需要MEDIA_CONTROL权限，这是个系统权限，普通应用没法获取；而安装系统应用又需要系统签名，我们显然是没办法拿到系统签名的；既然前面已经安装了Magisk，那就直接通过Xposed模块强行注册系统服务就好了！参考文章：[使用Xposed添加自定义系统服务 - HAOUTIL.COM](https://haoutil.com/posts/xposed-add-custom-system-service/)
实际验证发现注册系统服务的过程中即使服务名添加了`user.`前缀也仍然会报SELinux错误，那就直接想办法把他关掉，安装这个模块就可以实现：[GitHub - evdenis/selinux\_permissive: Magisk Module that switches SELinux to permissive mode](https://github.com/evdenis/selinux_permissive)
至此，仪表盘显示任意音乐应用的音乐信息就已经实现了，超额完成任务。
