---
source_hash: undefined
share: true
title: BJ40 Car Infotainment System Development
author: JasperZ
section: tech
tags:
  - BJ40
  - Android
date: 2025-08-14T16:43:00
layout: post
---
# Steering Wheel Controls
## adb logcat Analysis
```
# Log when navigation button is pressed
06-08 17:58:09.401  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng SrcMngAppOn() reqPackageName = com.tencent.wecar reqMap = null actionName = null
06-08 17:58:09.403  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng startLauncherApp() Begin requestAppPackageName = com.tencent.wecar
```

After decompiling `SourceMngService.apk` and analyzing its logic, we found that the application package name launched by the steering wheel controls is configured in the file `/system/etc/adayo/SourceMng/AdayoSourceMng.conf`. It appears we can modify this file to change the app launched by the Media key using the same approach.

# Navigation
Upon decompiling `NaviService.apk`, we discovered that both Tencent Map and AutoNavi (Amap) adaptation codes exist within the package. We attempted to switch the dashboard's navigation implementation by modifying the configuration file.

By examining the `com.adayo.service.navi.NaviConfig` class, we found the navigation configuration file located at `/etc/adayo/naviconf/naviconf.conf`. Further analysis revealed that the `MapType` enum value for AutoNavi is `Amap`.

However, actual testing showed that modifying this configuration file had no effect. Logcat indicated that `AmapNaviListener` was loaded normally, aligning with our earlier analysis. Therefore, it seems the dashboard navigation functionality is handled by another mechanism. We continued our investigation into `meterservice.apk`.

When enabling Tencent Navigation, we observed additional logs from the `NaviStatusReceiver` class, which handles navigation status change listeners. Other log tags such as `NAVI_STANDARD_NaviManager` appeared to involve critical logic.

Analyzing `NaviStatusReceiver` revealed it only handles platform-independent logic, so we disregarded it and pursued other clues.

Searching for `NaviManager` in `meterservice.apk` only revealed service connection logic. We suspected the core logic still resides in `NaviService.apk`, but upon revisiting it, no effective implementation was found. Could it be that the Tencent Navigation is a customized version, with the key logic inside the navigation package itself? Further inspection of the Tencent Navigation package also did not reveal relevant logic. Our attention then turned to the suspicious `txAdapterService.apk`.

Upon researching, we learned that manufacturers may compile the ROM to retain only optimized odex/vdex files and remove the original dex files from the APK. Therefore, we extracted the entire application directory from `/system/app` on the car infotainment system to obtain odex/vdex files.

Tools used:
- cdex to dex converter: [GitHub - fOmey/compact_dex_converter: cdex to dex binaries](https://github.com/fOmey/compact_dex_converter)
- vdex to cdex converter: [GitHub - anestisb/vdexExtractor: Tool to decompile & extract Android Dex bytecode from Vdex files](https://github.com/anestisb/vdexExtractor)  
  Note: This tool may fail to compile. To fix, edit `src/dex_instruction.c`, locate `kMaxVarArgRegs`, and change the parameter to a pointer type.

After decompiling, we found `txAdapterService` only contains music-related logic, which will be analyzed in detail in the Music section.

Further analysis of `framework.jar` revealed the implementation of `com.adayo.proxy.navigation.navi.NaviManager`, the source of the previously mentioned `NAVI_STANDARD_NaviManager` logs.

Looking back at the `AmapNaviListener` implementation, we found that `AmapNaviListener.InformationRecv` receives broadcasts and calls the `NaviManager` service. From the logs, it appears that the Amap broadcast is being received normally and `NaviManager` is being invoked correctly, indicating this logic is intact.

Analyzing `TxNaviListener`, we found that Tencent Navigation does not use system broadcasts but instead uses a private SDK. This logic resides in `TxTaesClient`. Upon inspection, we noticed that when Tencent Navigation starts, it initializes `TxNaviDisplayPresenter`, which contains display logic that only works when `NaviConfig.ProjectName` equals `HM6C14A`. The configuration file `/etc/adayo/naviconf/naviconf.conf` indeed has the project name set to `HM6C14A`.

Although `TxNaviListener` and `TxNaviDisplayPresenter` logs were not visible, no other options seemed plausible. We decided to implement a test display logic based on this discovery. Since AutoNavi’s car version doesn’t provide a communication SDK like Tencent, we may need to integrate a separate map SDK to handle the display logic.

# Music
## Method 1
The dashboard control logic resides in `meterservice.apk`. Specifically, network music control logic is located in `com.adayo.service.meterservice.control.NetMusicControl`. By searching for related methods, we found that `com.adayo.service.meterservice.managers.ControlManager` receives broadcasts from `ShareDataManager` and dispatches them to respective `Control` classes based on content. The dashboard service maintains the current audio source state by listening to `ShareData`. `NetMusicControl` determines whether to process media info based on whether the audio source is `TENCENT_WECAR_FLOW`. Therefore, maintaining or tampering with this state becomes crucial.

Still, we had not yet identified the Android system broadcast. We continued our analysis.

In `ShareDataManager`, a `ShareDataListener` map exists. Further analysis of `ShareDataListenerImpl` led us to a `Binder` in its base class `IShareDataListenerAIDL.Stub`, with the descriptor `com.adayo.proxy.infrastructure.share.aidl.IShareDataListenerAIDL`. This Binder receives data from other processes and forwards it as a `Bundle`.

Analyzing `ShareService.apk`, we found a configuration file at `/etc/shareinfo.json`. This package appears to be a low-level service handling data forwarding, with no business logic found.

We strongly suspected that the broadcast receiver and forwarding logic for AiQiTing reside in `txAdapterService.apk`. However, decompiling revealed no dex files inside the APK.

This was not a dead end — we had already identified some key methods. Next, we proceeded to flash Magisk and consider using modules!

The BJ40 infotainment system had no obvious way to enter fastboot mode. Commands like `adb reboot fastboot` and `adb reboot bootloader` had no effect. However, we could directly flash the boot partition using `dd` with root access.

We executed the following commands to extract the boot partitions:
```shell
dd if=/dev/block/by-name/boot_a of=/sdcard/boot_a.img
dd if=/dev/block/by-name/boot_b of=/sdcard/boot_b.img
```

Since the system had likely never been updated, the ab partitions were identical. We assumed the current boot partition was `boot_a`, and patched it using Magisk.

After patching, we flashed the modified boot image:
```shell
dd if=patched_boot.img of=/dev/block/by-name/boot_a
# Reboot after flashing
reboot
```

After rebooting, we checked Magisk status — success! During boot, Magisk warned about `su` conflicts with its built-in `su`. We resolved this by renaming `/xbin/su` via shell. After this, we noticed Zygisk was disabled by default, likely due to the earlier conflict. We re-enabled it via the Magisk settings page.

Next, we installed LSPosed. The installation was smooth, except that after enabling LSPosed on the car system, no notification appeared in the status bar, and no dialer app was available to follow the official setup guide. Eventually, we manually installed `manager.apk` from `/data/adb/magisk/services/lspd` to access the LSPosed settings.

## Method 2
We analyzed how the built-in media player sends track information. By decompiling `MultiMedia.apk` and searching for `sendShareData`, we found the actual sending method resides in `com.adayo.fpresenter.music.impl.depends.SourceDependImpl`. We considered extracting the `ShareDataManager` logic into a separate app and monitoring system media changes to send `ShareData`.

From the navigation analysis, we learned that music handling in `txAdapterService` uses the AiQiTing SDK to listen for system broadcasts, parse media state events, and convert them into `ShareData`. The key logic is as follows:
```java
public void saveShareData() {
    this.m_Map.put("artist", this.mediaAuthor);
    this.m_Map.put("name", this.mediaName);
    this.m_Map.put("status", this.mediaState);
    this.shareDataManager.sendShareData(61, this.gson.toJson(this.m_Map));
}
```
Here, `mediaState` is an enum string with values: `pause`, `stop`, `playing`.

Continuing analysis in `meterservice.apk`, we found that `SourceChangeInfo.dataType` is 14 in the `dealShareInfoData` method. The `Source` is updated solely via `ShareData`. We searched `SourceMngService` for data source logic related to 14 but found nothing obvious. However, theoretically, we can send a `ShareData` with `dataType=14` along with media info to update the `Source`. The implementation path is now clear — time to proceed.

Further decompiling `com.adayo.proxy.infrastructure.share.ShareDataManager`, we found that the service might be compiled into a custom `framework.jar`. We pulled this file from the car system and integrated it into our project using the method described in [How to integrate framework.jar in newer Android Studio versions - Juejin](https://juejin.cn/post/7276294701522255909).

Extracting `framework.jar` was challenging — the file `/system/framework/framework.jar` did not contain any dex files. As previously mentioned, manufacturers compile dex into vdex during ROM building. Following earlier steps, we decompiled `/system/framework/arm64/boot-framework.vdex` into dex, converted it to a jar using `dex2jar`, and merged it into `framework.jar`.

To monitor system media info, we need the `MEDIA_CONTROL` permission, a system-level permission inaccessible to regular apps. Since we already installed Magisk, we decided to forcibly register a system service using an Xposed module. Reference: [Using Xposed to Add a Custom System Service - HAOUTIL.COM](https://haoutil.com/posts/xposed-add-custom-system-service/)

However, during testing, even with the service name prefixed with `user.`, SELinux errors occurred. To resolve this, we installed the following Magisk module to switch SELinux to permissive mode:  
[GitHub - evdenis/selinux_permissive: Magisk Module that switches SELinux to permissive mode](https://github.com/evdenis/selinux_permissive)

With this setup, we successfully displayed music info from any music app on the dashboard — exceeding our original goal.