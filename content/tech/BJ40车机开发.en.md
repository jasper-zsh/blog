---
source_hash: ed4dce7eda6879b941f36e31adb96fda4c5bb50d346e943c6394da33726c9232
share: true
title: BJ40 Car Infotainment System Development
author: JasperZ
section: tech
tags:
  - BJ40
  - Android
date: 2025-08-14T16:43:00
layout: post
---
# Steering Wheel Controls
## ADB Logcat Analysis
```
# Navigation button press log
06-08 17:58:09.401  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng SrcMngAppOn() reqPackageName = com.tencent.wecar reqMap = null actionName = null
06-08 17:58:09.403  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng startLauncherApp() Begin requestAppPackageName = com.tencent.wecar
```

After decompiling `SourceMngService.apk` and analyzing its logic, we found that the application package names for the steering wheel controls are configured in the file `/system/etc/adayo/SourceMng/AdayoSourceMng.conf`. It appears that we can modify the application launched by the media button using the same method.

# Navigation
By decompiling `NaviService.apk`, we found that it contains adaptation code for both Tencent Maps and AutoNavi (Amap). We attempted to switch the navigation implementation on the dashboard by modifying the configuration file.

By examining the `com.adayo.service.navi.NaviConfig` class, we found that the navigation configuration file is located at `/etc/adayo/naviconf/naviconf.conf`. Through analysis, we determined that the `MapType` enumeration value corresponding to AutoNavi is `Amap`.

However, practical testing showed that modifying this configuration file had no effect. Logcat showed that `AmapNaviListener` was loading normally, consistent with our previous analysis. This suggests that the dashboard navigation display is handled by another mechanism. We continued analyzing `meterservice.apk`.

While observing logs during the activation of Tencent Navigation, we found additional logs from the `NaviStatusReceiver` class, which handles navigation status change listeners. Additionally, some log tags like `NAVI_STANDARD_NaviManager` appeared to be involved in key logic.

We analyzed `NaviStatusReceiver`, but it only handles platform-independent logic, so we ignored it and pursued other leads.

Searching for `NaviManager` in `meterservice.apk` only revealed service connection logic. We suspected that the key logic was still in `NaviService.apk`. However, upon revisiting `NaviService.apk`, we found no effective implementation. Could it be that Tencent Navigation is a customized version, and the key logic resides in the navigation APK itself? After checking the Tencent Navigation APK and finding no relevant logic, our attention turned to the suspicious `txAdapterService.apk`.

Research revealed that manufacturers may retain only optimized odex/vdex files during ROM compilation, removing the original dex files from the APK. Therefore, we returned to the car infotainment system to extract the entire application directory under `/system/app` to obtain the odex/vdex files.

Tools for converting cdex to dex: [GitHub - fOmey/compact_dex_converter: cdex to dex binarys](https://github.com/fOmey/compact_dex_converter)  
Tools for converting vdex to cdex: [GitHub - anestisb/vdexExtractor: Tool to decompile & extract Android Dex bytecode from Vdex files](https://github.com/anestisb/vdexExtractor)  
Note: This tool may fail to compile. To fix, edit `src/dex_instruction.c`, search for `kMaxVarArgRegs`, and change this parameter to a pointer type to allow successful compilation.

After decompiling `txAdapterService.apk`, we found only music-related logic, which will be analyzed in detail in the "Music" section.

Further analysis of `framework.jar` revealed that it contains the implementation of `com.adayo.proxy.navigation.navi.NaviManager`, the class responsible for the previously mentioned `NAVI_STANDARD_NaviManager` logs. Revisiting the `AmapNaviListener` implementation, we found that `AmapNaviListener.InformationRecv` receives broadcasts and calls methods in `NaviManager`. This class registers a `BroadcastReceiver` upon construction and successfully receives broadcasts from AutoNavi according to the logs. It also properly invokes methods in the `NaviManager` service, indicating that the logic is intact.

We then analyzed the logic in `TxNaviListener`. Unlike AutoNavi, Tencent Navigation does not use system broadcasts but instead uses a private SDK to receive navigation app information, implemented in `TxTaesClient`. Upon inspecting this class, we noticed that when Tencent Navigation starts, it initializes a `TxNaviDisplayPresenter` class containing display logic that only activates when `NaviConfig.ProjectName` equals `HM6C14A`. Notably, the configuration file `/etc/adayo/naviconf/naviconf.conf` indeed sets the project name as `HM6C14A`. Although `TxNaviListener` does not seem to be loaded and no `TxNaviDisplayPresenter` logs appear, there appear to be no other possibilities. We decided to emulate this implementation and create a test display logic. Since AutoNavi’s car version does not provide a communication SDK like Tencent, if this test works, we may need to integrate a separate map SDK to handle the display logic.

# Music
## Method 1
The dashboard control logic resides in `meterservice.apk`, specifically in the `com.adayo.service.meterservice.control.NetMusicControl` class for network music information control. Searching for related methods revealed that `com.adayo.service.meterservice.managers.ControlManager` receives broadcasts from `ShareDataManager` and dispatches the content to various `Control` classes for processing. The dashboard service maintains the current audio source status by listening to `ShareData`. `NetMusicControl` decides whether to process media information based on whether the audio source is `TENCENT_WECAR_FLOW`. Therefore, maintaining or tampering with this state must be considered carefully.

At this point, we still hadn't identified the Android system broadcasts. We continued our analysis.

In `ShareDataManager`, a `ShareDataListener` map is maintained. Further examination of `ShareDataListenerImpl` eventually led us to a `Binder` in its base class `IShareDataListenerAIDL.Stub`. Its descriptor is `com.adayo.proxy.infrastructure.share.aidl.IShareDataListenerAIDL`, and it receives data from other processes and converts it into a `Bundle` for downstream dispatching.

Analyzing `ShareService.apk`, we found a configuration file named `/etc/shareinfo.json`. This package appears to be a low-level service handling data forwarding, but it contains no specific business logic.

We strongly suspect that the broadcast receiving and forwarding logic for AiQiTing resides in `txAdapterService.apk`, but decompiling it revealed no dex files???

Not finding the path is not a problem for now. We've already identified some key methods. Next, we'll flash Magisk and consider using modules to achieve our goals!

The BJ40 infotainment system doesn't seem to support fastboot entry. Attempts using `adb reboot fastboot` and `adb reboot bootloader` both failed. No problem — we can directly use root permissions to force flash via `dd`.

Execute the following commands to extract the boot partition:
```shell
dd if=/dev/block/by-name/boot_a of=/sdcard/boot_a.img
dd if=/dev/block/by-name/boot_b of=/sdcard/boot_b.img
```

Since the system may not have been updated, the extracted A/B partitions were identical. We assumed the current system is using the A partition and patched it with Magisk.

After patching, force flash the modified boot image:
```shell
dd if=patched_boot.img of=/dev/block/by-name/boot_a
# Reboot after flashing
reboot
```

After rebooting, check the Magisk status. Success on the first try! Magisk prompts that `su` conflicts with its own `su` binary. Enter shell and move `/xbin/su` somewhere else (e.g., rename it). After resolving this, we found that Zygisk was disabled by default, likely due to the previous conflict. Enter the Magisk settings page and enable Zygisk.

Next, install LSPosed. The installation was smooth. The only issue is that after enabling LSPosed on the car infotainment system, no notification appears in the status bar, and there is no dialer app to access the configuration page as instructed on the official website. Eventually, we found `manager.apk` manually installable in `/data/adb/magisk/services/lspd`, allowing us to open the LSPosed settings page.

## Method 2
We analyzed how the built-in media player transmits track information. By decompiling `MultiMedia.apk` and searching for `sendShareData`, we found that the actual sending method resides in the class `com.adayo.fpresenter.music.impl.depends.SourceDependImpl`. We considered extracting the `ShareDataManager` logic and integrating it into a separate app that listens for system media changes and sends `ShareData`.

During navigation analysis, we found that music handling in `txAdapterService` works by using the AiQiTing SDK to listen for system broadcasts, parse media state events, and convert them into `ShareData` for transmission. Key logic:
```
public void saveShareData() {
  
        this.m_Map.put("artist", this.mediaAuthor);
  
        this.m_Map.put("name", this.mediaName);
  
        this.m_Map.put("status", this.mediaState);
  
        this.shareDataManager.sendShareData(61, this.gson.toJson(this.m_Map));
  
    }
```

Here, `mediaState` is a string enum with values: `pause`, `stop`, `playing`.

We continued analyzing `meterservice.apk` to explore how `Source` is maintained. In the `dealShareInfoData` method, we found that `SourceChangeInfo.dataType` is 14, and the only update source for `Source` is `ShareData`. We tried searching for 14 in `SourceMngService` but found nothing, though it may not matter. Theoretically, we only need to send `ShareData` with `dataType` 14 alongside media information to update `Source`. The implementation method is now clear — time to proceed!

By decompiling `com.adayo.proxy.infrastructure.share.ShareDataManager`, we found that the service it calls might be compiled into a customized `framework.jar`. We pulled it from the car system and integrated it into our project, following the method described here: [High-version Android Studio integration of framework.jar - Juejin](https://juejin.cn/post/7276294701522255909)

Extracting `framework.jar` was challenging — the file `/system/framework/framework.jar` did not contain dex files. As previously noted, manufacturers convert dex files to vdex during compilation. Following earlier methods, we decompiled `/system/framework/arm64/boot-framework.vdex` to dex, converted it to jar using `dex2jar`, and merged it into `framework.jar` for use.

Monitoring system media information requires the `MEDIA_CONTROL` permission, a system-level permission that normal apps cannot obtain. Installing system apps also requires system signing, which we obviously don't have access to. Since we already installed Magisk, we decided to directly register the system service via an Xposed module! Reference: [Using Xposed to Add a Custom System Service - HAOUTIL.COM](https://haoutil.com/posts/xposed-add-custom-system-service/)

During actual testing, even when the service name included the `user.` prefix, SELinux errors still occurred. So we decided to disable SELinux directly. This module can help: [GitHub - evdenis/selinux_permissive: Magisk Module that switches SELinux to permissive mode](https://github.com/evdenis/selinux_permissive)

With this, we successfully enabled the dashboard to display music information from any music app — exceeding our initial goal.