---
source_hash: undefined
share: true
title: BJ40 Car Infotainment System Development
author: JasperZ
section: tech
tags:
  - BJ40
  - Android
date: 2025-08-14T16:43:00
layout: post
---
# Steering Wheel Controls
## ADB Logcat Analysis
```
# Navigation button trigger log
06-08 17:58:09.401  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng SrcMngAppOn() reqPackageName = com.tencent.wecar reqMap = null actionName = null
06-08 17:58:09.403  3474  3913 D SM_Service_V2_20210412: SrcMngServiceMng startLauncherApp() Begin requestAppPackageName = com.tencent.wecar

# 
```

By decompiling the `SourceMngService.apk`, it was determined that the application package names for the steering wheel controls are configured in the file `/system/etc/adayo/SourceMng/AdayoSourceMng.conf`. It appears that the same method can be used to modify the application switched by the Media key.

# Navigation
Decompiling the `NaviService.apk` revealed that both Tencent Map and AutoNavi map adaptation codes coexist. An attempt was made to change the dashboard navigation implementation by modifying the configuration file. 
Upon examining the `com.adayo.service.navi.NaviConfig` class, it was found that the navigation configuration file is located at `/etc/adayo/naviconf/naviconf.conf`. Analysis also revealed that the MapType enumeration value for AutoNavi is `Amap`;
Practical testing showed that modifying this configuration file had no effect. By observing the logs, it was noted that AmapNaviListener loaded normally, aligning with previous analysis results. Therefore, it appears that the dashboard navigation effect is handled by another mechanism, prompting further analysis of the `meterservice.apk`.

While enabling Tencent Navigation, additional logs from the dashboard service were observed: the `NaviStatusReceiver` class handled some navigation state change listeners, and there were other log tags such as `NAVI_STANDARD_NaviManager` which seemed to involve key logic.

First, the NaviStatusReceiver was analyzed, but it only handled some platform-independent logic, so it was ignored, and other clues were pursued.

Searching for `NaviManager` in `meterservice.apk` only revealed some service connection logic, leading to the speculation that these key logics are still in `NaviService.apk`. However, upon returning to search this package, no effective implementation was found. Could it be that Tencent Navigation is a customized version with key logics in the navigation package? Checking Tencent Navigation also did not reveal related logic, so attention turned to the suspicious package `txAdapterService.apk`. Research showed that manufacturers can choose to retain only the optimized odex/vdex files when compiling ROMs, while removing the dex files from the apk. Therefore, the entire application directory was extracted from the car system under `/system/app` to obtain the odex/vdex.

Tools for converting cdex to dex: [GitHub - fOmey/compact\_dex\_converter: cdex to dex binarys](https://github.com/fOmey/compact_dex_converter)
Tools for converting vdex to cdex: [GitHub - anestisb/vdexExtractor: Tool to decompile & extract Android Dex bytecode from Vdex files](https://github.com/anestisb/vdexExtractor)
This tool may report errors when compiled; edit `src/dex_instruction.c`, search for `kMaxVarArgRegs`, and change this parameter to a pointer type to compile successfully.

After decompiling, it was found that `txAdapterService` only contains music processing logic, which will be analyzed in detail in the music section.

The subsequent analysis of the obtained `framework.jar` revealed that it contains the implementation of `com.adayo.proxy.navigation.navi.NaviManager`, the source of the previously mentioned `NAVI_STANDARD_NaviManager` key logs. Looking back at the implementation of `AmapNaviListener`, it was found that `AmapNaviListener.InformationRecv` implements the reception of broadcasts, with logic to invoke the NaviManager service. This class registers a BroadcastReceiver during its construction and, from the logs, it can be seen that it normally receives broadcasts from AutoNavi and invokes methods of the NaviManager service, indicating that the logic of this class is intact.
Looking back at the logic of TxNaviListener, Tencent WeCar does not use system broadcasts but instead uses a proprietary SDK to receive information from the navigation software, with logic in TxTaesClient. Observing this class reveals a peculiar point: when it detects the launch of Tencent WeCar, it initializes a TxNaviDisplayPresenter class, which includes some display logic. These logics are only effective when the ProjectName in NaviConfig equals `HM6C14A`, and the Project in `/etc/adayo/naviconf/naviconf.conf` is indeed `HM6C14A`. Although from the logs it seems that TxNaviListener is not loaded, nor are there logs for TxNaviDisplayPresenter, it seems there are no other possibilities left. A test display logic will be written following this implementation; since the in-vehicle version of AutoNavi Map does not provide a communication SDK like Tencent WeCar, if the test is effective, it may be necessary to integrate a separate map SDK to handle the display logic.
# Music
## Method 1
The dashboard control logic is in the `meterservice.apk`, where the network music information control logic is found in `com.adayo.service.meterservice.control.NetMusicControl`. Searching for related methods shows that in `com.adayo.service.meterservice.managers.ControlManager`, broadcasts from ShareDataManager are received and their content is used to dispatch to various types of Control to process the information; the dashboard service listens to ShareData to maintain the current audio source state. In NetMusicControl, it decides whether to process media information based on whether the audio source is TENCENT_WECAR_FLOW. Therefore, how to correctly maintain or tamper with this state needs to be considered in the future;
So far, no Android system broadcasts have been found, so further analysis is needed.
In `ShareDataManager`, a Map of ShareDataListener is maintained. Continuing to view the implementation of `ShareDataListenerImpl`, ultimately in its base class `IShareDataListenerAIDL.Stub`, a Binder was found whose descriptor is `com.adayo.proxy.infrastructure.share.aidl.IShareDataListenerAIDL`. This receives data from other processes and converts it into a Bundle for further dispatch.
Analyzing `ShareService.apk`, a configuration file `/etc/shareinfo.json` was found. This package seems to handle the forwarding of the underlying services and does not contain specific business information.
At this point, it is highly suspected that the broadcast reception and forwarding of iQIYI are in the `txAdapterService.apk` package, but after unpacking, no dex files were found? ??

It doesn't matter if the path cannot be found temporarily. Some key methods have already been discovered. The next step is to flash Magisk, and later consider using a module!
The BJ40 car system cannot find a way to enter fastboot. Attempts to use `adb reboot fastboot` and `adb reboot bootloader` were ineffective, but it's okay, just directly use root permissions to force flash via dd.
Execute the following commands to extract the boot partition
```shell
dd if=/dev/block/by-name/boot_a of=/sdcard/boot_a.img
dd if=/dev/block/by-name/boot_b of=/sdcard/boot_b.img
```

Since the system may not have been upgraded, the extracted a and b partitions are the same. It is guessed that the current one is using the a partition, so patch it with magisk!
After patching, similarly use dd to force flash
```shell
dd if=patched boot.img of=/dev/block/by-name/boot_a
# Reboot after flashing
reboot
```

After rebooting, check the status in Magisk, and one success! When Magisk starts, it will prompt that there is a conflict between su and the su built into Magisk. Enter the shell to move `/xbin/su` (for example, rename it), and after handling, it is found that Zygisk is turned off by default, which may be related to the previous conflict. Enter the Magisk settings page to turn it on.
Then install LSPosed, the installation process is uneventful, the only thing to note is that after enabling LSPosed on the car system, the notification bar will not display its notification, and the dialer software cannot be found in the car system to follow the official guide to enter the configuration page; finally in `/data/adb/magisk/services/lspd` find `manager.apk` and install it manually, then you can open the LSPosed settings page.

## Method 2
Analyze how the built-in media player transmits track information. Decompile `MultiMedia.apk` and search for `sendShareData`. It was found that the actual sending method is in the class `com.adayo.fpresenter.music.impl.depends.SourceDependImpl`. It is possible to consider extracting the logic of ShareDataManager and integrating it into a separate App, then normally monitoring changes in system media information to deliver ShareData.

During the analysis of navigation, it was found that the handling of music is in `txAdapterService`. The principle is to use the iQIYI SDK to monitor system broadcasts, parse media status events, and convert them into ShareData for sending. The key logic is as follows:
```
public void saveShareData() {
  
        this.m_Map.put("artist", this.mediaAuthor);
  
        this.m_Map.put("name", this.mediaName);
  
        this.m_Map.put("status", this.mediaState);
  
        this.shareDataManager.sendShareData(61, this.gson.toJson(this.m_Map));
  
    }
```

Here, mediaState is a string enumeration with values `pause`, `stop`, `playing`.

Next, continue analyzing `meterservice.apk` to explore how Source is maintained. In the `dealShareInfoData` method, it was found that the dataType of SourceChangeInfo is 14, and the only update source of Source is ShareData. Try to find the source of data in SourceMngService, but a simple search for 14 did not yield results, though it may not be important. Theoretically, as long as a ShareData with dataType 14 is sent along with the media information, Source can be updated; the implementation method has been determined, time to start working!

Analyzing the decompiled code of `com.adayo.proxy.infrastructure.share.ShareDataManager`, it was found that this class calls services that might be compiled into a custom framework.jar. Extract it from the vehicle system and add it to the project. The method reference is [Integrating framework.jar in High Version Android Studio - Juejin](https://juejin.cn/post/7276294701522255909).
The process of extracting framework.jar was also somewhat difficult, as `/system/framework/framework.jar` does not contain dex files. As previously discussed, manufacturers convert dex to vdex during the compilation process for storage. Following the previous method, `/system/framework/arm64/boot-framework.vdex` was decompiled into dex, converted to a jar package using `dex2jar`, and merged into framework.jar for use.
Monitoring system media information requires the MEDIA_CONTROL permission, which is a system permission that ordinary applications cannot obtain; and installing system applications requires system signing, which we obviously cannot obtain. Since Magisk has been installed earlier, it is straightforward to forcibly register the system service through an Xposed module! Reference article: [Using Xposed to Add Custom System Services - HAOUTIL.COM](https://haoutil.com/posts/xposed-add-custom-system-service/)
During practical verification, even if the service name is prefixed with `user.`, a SELinux error will still be reported during the registration of the system service. Therefore, try to disable it directly. Install this module to achieve it: [GitHub - evdenis/selinux_permissive: Magisk Module that switches SELinux to permissive mode](https://github.com/evdenis/selinux_permissive)
So far, displaying music information from any music application on the dashboard has been achieved, exceeding the task requirements.