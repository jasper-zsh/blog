---
source_hash: fdef8c843cc6ba1e2511b0efb3bf75f70432e1787ddc7d55f727d2206f442d90
---
# Analysis of the Bluetooth Protocol for Junce Coulomb Meter

According to the analysis of the behavior of `uni.getBLEDeviceServices`, it was determined that the protocol uses the second-to-last service (a rather brute-force approach).  
The `monitor` method is used to initiate data listening. By searching for `uni.onBLECharacteristicValueChange`, we can determine that the callback method for handling incoming data is `rxd`.

The purposes of the BLE characteristics are as follows:

| Index | UUID | Purpose          |
|-------|------|------------------|
| 0     | FFF1 | Receive data     |
| 1     | FFF2 | Send commands    |

# Data Processing

All numbers in this protocol are parsed by directly interpreting HEX values as decimal number strings. This will not be reiterated in the following sections.

## Some Special Packets

- `0x48`: Firmware is being upgraded
- `0x4848`: Unknown, suspected to indicate upgrade completion
- `0x44`: `t.online = true`, likely indicates connection status
- `0x45`: Upgrade failed
- `0x43`: `true1` increments — this is a counter with an unknown purpose

## Data Packets

Normal data packets start with either `0xBB` or `0xAA` and end with `0xEE`.  
The packet processing logic is somewhat brute-force — packet types are determined by inclusion and categorized into three types:

- `0xA0`: Chart data object, processed by `historyStrToObj`
- `0xF4`: Chart data timestamp, processed by `historyTimeStrToObj`
- All other cases are treated as general data objects, processed by `strToObj`

### Data Objects

The data stream is not structured as a standard binary stream, so byte order does not need to be considered. However, the decompiled logic processes data in a way that resembles little-endian (from right to left). In single-byte HEX format, pure numeric values represent decimal integers (converted directly as decimal strings), while other values represent data fields. The meanings of each field are as follows:

| Field | Meaning                                           |
|-------|---------------------------------------------------|
| 0xF6  | Password                                          |
| 0xE0  | Data loading in progress — send `0x9AA9` to continue, or `0x9AE0` to start |
| 0xD2  | Remaining battery — 6-digit format DDD.DDD        |
| 0xB0  | Total battery capacity — 4-digit format DDD.D     |
| 0xF9  | Low battery alarm percentage — 2 digits           |
| 0xF7  | To be confirmed — temperature unit                |
| 0xD9  | Temperature — first 2 digits are unit, last 2 digits are integer temperature |
| 0xC0  | Voltage — 4-digit format DD.DD                    |
| 0xC1  | Current — 4-digit format DD.DD                    |
| 0xD8  | Power (in Watts) — 6-digit format DDDD.DD         |
| 0xC4  | Address match — 2 digits                          |
| 0xB7  | Relay type — 0: normally open, 1: normally closed |
| 0xD5  | Number of data records                            |
| 0xF1  | Data recording switch — 0: on, 1: off             |
| 0xF8  | Data recording interval — 2 digits, interval = value + 1 |

### Data Object Parsing Logic (`strToObj`)

Parsing is done from right to left. The first byte indicates the field, and subsequent bytes that can be directly interpreted as decimal numbers represent the value.

### Commands

When sending data, there are several special logic rules. The pseudo-code is as follows:

```javascript
writeDataValue = data
if writeDataValue == 0x9AA9
	send(0xBB9AA90CEE)
else
	if writeDataValue == 'AR' or 'AD'
		send(strToArrayBuffer(writeDataValue))
	else
		if writeDataValue contains 'b9', 'b8', 'f4', 'f6', 'f2', 'e1'
			send(0xBB + data + 0x0CEE)
		else
			send(checkAdd(writeDataValue))
```

Obviously, there are two special commands `AR` and `AD`, which are not in HEX format.  
`AR` and `AD` appear to be used during firmware upgrades and will not be analyzed further for now.  

The `checkAdd` function is implemented as follows:

```javascript
checkAdd(data)
	payload = 0xBB + data
	checksum = 0
	for b in payload
		checksum += b
	if password
		checksum = checksumWithPassword(checksum + password)
	else
		checksum = checksum[-1:]
	return payload + checksum + 0xEE
```

Based on the magic numbers in the pseudo-code and the implementation of `checkAdd`, the last byte of the packet is the checksum. However, in practical testing, it was observed that without a password, this byte is always `0x0C`.

| Command                                             | Meaning                              |
|----------------------------------------------------|--------------------------------------|
| `0x9AE0`                                           | Start loading data                   |
| `0x9AA9`                                           | Request data object                  |
| `0x9AF6`                                           | Unknown — used in password exchange  |
| `0x9AF9 + byte + 0xF9`                             | Set low battery alert threshold (%)  |
| `0x00A5`                                           | Factory reset                        |
| `0x00A6`                                           | Reboot device                        |
| `0x9AC100A4`                                       | CurrentClear                         |
| `0x9AC4 + byte + C4`                               | Set communication address            |
| `0x9AC3 + byte + C3`                               | Tpton                                |
| `0x9AC2 + byte + C2`                               | Tptoff                               |
| `0x9AE9 + byte + E9`                               | Min — byte is actual value × 10      |
| `0x9AE7 + byte + E7`                               | LossVoltage — byte is actual × 100   |
| `0x9AE8 + byte + E8`                               | FullCurrent — byte is actual, last 2 digits truncated (to be confirmed) |
| `0x9AE6 + byte + E6`                               | FullVoltage — byte is actual × 100   |
| `0x9AB7 + byte + B7`                               | Relay type — byte is 00 or 01, meaning to be confirmed |
| `0x9AE3 + byte + E3`                               | LTP — byte has a complex calculation logic, see below |
| `0x9AB1 + byte + B1`                               | ETP — byte has a complex calculation logic, see below |
| `0x9AC9 + byte + C9`                               | OPP — byte is actual × 100           |
| `0x9AC8 + byte + C8`                               | NCP — byte is actual × 100           |
| `0x9AC7 + byte + C7`                               | OCP — byte is actual × 100           |
| `0x9AC6 + byte + C6`                               | LVP — byte is actual × 100           |
| `0x9AC5 + byte + C5`                               | OVP — byte is actual × 100           |
| `0x9AF1 + byte + F1`                               | Data logging — 00: on, 01: off        |
| `0x9AF8 + byte + F8`                               | Clear data logs — logic to be analyzed |
| `bytes(yymmdd) + 0xF2 + bytes(hhiiss) + 0xF39AF29AF3` | Set date and time                    |
| `0x9AD2 + byte + D2`                               | MBFree — logic to be analyzed        |
| `0x9AB0 + byte + 0xB0`                             | Set battery capacity — byte × 10, max 9999 |
| `0x9AE39AB19AF70255E30255B1 + byte + F7`           | Set temperature unit — byte logic to be confirmed |
| `0x9AD99AB4 + byte + B4`                           | Set temperature (to be confirmed) — byte is actual value |
| `0x9AC09AB2 + byte + B2`                           | VoltageAlign                         |
| `0x9AC19AB3 + byte + B3`                           | CurrentAlign                         |

#### LTP / ETP Calculation Logic