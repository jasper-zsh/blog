---
source_hash: undefined
---
# Analysis of Bluetooth Protocol for Junce Coulometer

author: JasperZ
section: tech
tags:
  - Car Enthusiast
  - Embedded Development
date: 2025-08-14
share: true
layout: post

---

# Overview

According to the analysis of service selection behavior using `uni.getBLEDeviceServices`, the protocol uses the second-to-last service (in a rather crude manner).  
The `monitor` method is used to initiate data monitoring. By searching for `uni.onBLECharacteristicValueChange`, we find that the callback method for handling monitoring data is `rxd`.

The usages of the characteristics are as follows:

| Index | UUID | Purpose        |
| ---   | ---- | ------------- |
| 0     | fff1 | Receive data  |
| 1     | fff2 | Send commands |

# Data Processing

All numbers in the protocol are parsed by treating HEX values directly as decimal numeric strings. This will not be reiterated in the following text.

## Some Special Packets
- 0x48: Firmware upgrade in progress
- 0x4848: Unknown, suspected to indicate upgrade completion
- 0x44: `t.online = true`, likely indicates connection status
- 0x45: Upgrade failed
- 0x43: `true1` increments; this is a counter with unknown usage

## Data Packets

Normal data packets start with 0xBB or 0xAA and end with 0xEE.  
The packet processing logic is quite crude. The packet type is determined using a contains-style check and categorized into three types:
- 0xA0: Chart data object, processed by the `historyStrToObj` function
- 0xF4: Chart data timestamp, processed by the `historyTimeStrToObj` function
- All other cases are treated as data objects, processed by the `strToObj` function

### Data Object

The data stream is not structured as a standard binary stream, so there's no need to consider endianness. However, the decompiled processing logic still resembles little-endian format (processed from right to left). In the case of single-byte HEX values that are purely numeric, they represent decimal integers (converted directly as decimal strings), while other values represent data fields. The meanings of each field are shown in the table below:

| Field | Meaning                                      |
| ----- | ------------------------------------------- |
| 0xF6  | Password                                    |
| 0xE0  | Data loading in progress. Send 0x9AA9 to continue fetching data, or 0x9AE0 to start loading |
| 0xD2  | Remaining battery, 6-digit format DDD.DDD     |
| 0xB0  | Total battery, 4-digit format DDD.D           |
| 0xF9  | Low battery warning percentage, 2-digit       |
| 0xF7  | Pending confirmation, temperature unit        |
| 0xD9  | Temperature, first two digits are unit, next two are integer temperature |
| 0xC0  | Voltage, 4-digit format DD.DD                 |
| 0xC1  | Current, 4-digit format DD.DD                 |
| 0xD8  | Power, unit in W, 6-digit format DDDD.DD      |
| 0xC4  | Address match, 2-digit                      |
| 0xB7  | Relay type, 0 for normally open, 1 for normally closed |
| 0xD5  | Number of data records                        |
| 0xF1  | Data logging switch, 0 for on, 1 for off      |
| 0xF8  | Data logging interval, 2-digit value = interval - 1 |

### Data Object Parsing Logic (`strToObj`)

Parsing is done from right to left. The first byte is the field, subsequent bytes that can be directly parsed as decimal numbers are the value.

### Commands

When sending data, there are some special logic rules. Pseudocode is as follows:
```
writeDataValue = data
if writeDataValue == 0x9AA9
    send(0xBB9AA90CEE)
else
    if writeDataValue == 'AR' or 'AD'
        send(strToArrayBuffer(writeDataValue))
    else
        if writeDataValue contains 'b9', 'b8', 'f4', 'f6', 'f2', 'e1'
            send(0xBB + data + 0x0CEE)
        else
            send(checkAdd(writeDataValue))
```

Clearly, there are two special commands: `AR` and `AD`, which are not in HEX format.  
`AR` and `AD` appear to be used during firmware upgrades and will not be analyzed for now.  
The pseudocode for `checkAdd` is as follows:
```
checkAdd(data)
    payload = 0xBB + data
    checksum = 0
    for b in payload
        checksum += b
    if password
        checksum = checksumWithPassword(checksum + password)
    else
        checksum = checksum[-1:]
    return payload + checksum + 0xEE
```

Based on the magic numbers in the pseudocode and the implementation of `checkAdd`, the last byte of the packet is the checksum. However, actual transmission experiments show that this byte is fixed at 0x0C when no password is used.

| Command                                              | Meaning                                 |
| ---------------------------------------------------- | -------------------------------------- |
| 0x9AE0                                               | Start data loading                      |
| 0x9AA9                                               | Retrieve data object                    |
| 0x9AF6                                               | Unknown, used for password interaction  |
| 0x9AF9 + byte + 0xF9                                 | Set low battery warning threshold (%)   |
| 0x00A5                                               | Factory reset                           |
| 0x00A6                                               | Reboot device                           |
| 0x9AC100A4                                           | CurrentClear                            |
| 0x9AC4 + byte + C4                                   | Set communication address               |
| 0x9AC3 + byte + C3                                   | Tpton                                   |
| 0x9AC2 + byte + C2                                   | Tptoff                                  |
| 0x9AE9 + byte + E9                                   | Min, byte = actual value * 10           |
| 0x9AE7 + byte + E7                                   | LossVoltage, byte = actual value * 100  |
| 0x9AE8 + byte + E8                                   | FullCurrent, byte = actual value truncated last 2 digits (to confirm) |
| 0x9AE6 + byte + E6                                   | FullVoltage, byte = actual value * 100  |
| 0x9AB7 + byte + B7                                   | Relay type, byte = 00 or 01, meaning to confirm |
| 0x9AE3 + byte + E3                                   | LTP, byte has a complex calculation logic, described below |
| 0x9AB1 + byte + B1                                   | ETP, byte has a complex calculation logic, described below |
| 0x9AC9 + byte + C9                                   | OPP, byte = actual value * 100          |
| 0x9AC8 + byte + C8                                   | NCP, byte = actual value * 100          |
| 0x9AC7 + byte + C7                                   | OCP, byte = actual value * 100          |
| 0x9AC6 + byte + C6                                   | LVP, byte = actual value * 100          |
| 0x9AC5 + byte + C5                                   | OVP, byte = actual value * 100          |
| 0x9AF1 + byte + F1                                   | Data logging, 00 for on, 01 for off     |
| 0x9AF8 + byte + F8                                   | Clear data logs, logic to be analyzed   |
| bytes(yymmdd) + 0xF2 + bytes(hhiiss) + 0xF39AF29AF3  | Set date and time                       |
| 0x9AD2 + byte + D2                                   | MBFree, logic to be analyzed            |
| 0x9AB0 + byte + 0xB0                                 | Set battery capacity, byte = actual value * 10, max 9999 |
| 0x9AE39AB19AF70255E30255B1 + byte + F7               | Set temperature unit, byte logic to confirm |
| 0x9AD99AB4 + byte + B4                               | Set temperature (to confirm), byte = actual value |
| 0x9AC09AB2 + byte + B2                               | VoltageAlign                            |
| 0x9AC19AB3 + byte + B3                               | CurrentAlign                            |

#### LTP/ETP Calculation Logic