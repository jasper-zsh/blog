---
source_hash: undefined
---
# Analysis of the Junce Coulomb Meter Bluetooth Protocol

According to the behavior analysis of the `uni.getBLEDeviceServices` method for selecting services, the protocol uses the second-to-last service (in a rather crude manner).

The `monitor` method is used to initiate data monitoring. By searching for `uni.onBLECharacteristicValueChange`, we determine that the callback method for handling the monitored data is `rxd`.

The usages of the BLE characteristics are as follows:

| Index | UUID | Purpose            |
|-------|------|--------------------|
| 0     | FFF1 | Receiving data     |
| 1     | FFF2 | Sending commands   |

# Data Handling

All numbers in the protocol are parsed by treating the HEX values directly as decimal numeric strings. This will not be reiterated in the following text.

## Some Special Packets

- `0x48`: Firmware upgrade in progress  
- `0x4848`: Unknown, possibly indicates upgrade completion  
- `0x44`: `t.online = true`, likely indicates connection status  
- `0x45`: Upgrade failed  
- `0x43`: `true1` increments; this is a counter with unknown purpose  

## Data Packets

Normal data packets start with either `0xBB` or `0xAA`, and end with `0xEE`.

The packet handling logic is quite crude: packet types are determined by inclusion and are categorized into three types:

- `0xA0`: Chart data object, handled by the `historyStrToObj` function  
- `0xF4`: Chart data timestamp, handled by the `historyTimeStrToObj` function  
- All other cases are treated as regular data objects, handled by the `strToObj` function  

### Data Objects

The data stream is not constructed as a standard binary stream, so byte order is not an issue. However, the disassembled processing logic still resembles little-endian (processed from right to left). In single-byte HEX format, purely numeric values represent decimal integers (converted directly as decimal strings), while other values represent data fields. The meanings of each field are as follows:

| Field | Meaning                                      |
|-------|----------------------------------------------|
| 0xF6  | Password                                     |
| 0xE0  | Data loading in progress; send `0x9AA9` to continue, or `0x9AE0` to start |
| 0xD2  | Remaining battery, 3-digit format DDD.DDD     |
| 0xB0  | Total battery, 4-digit format DDD.D           |
| 0xF9  | Low battery alert percentage, 2-digit         |
| 0xF7  | Pending confirmation, temperature unit        |
| 0xD9  | Temperature, first two bytes are unit, next two are integer value |
| 0xC0  | Voltage, 4-digit format DD.DD                 |
| 0xC1  | Current, 4-digit format DD.DD                 |
| 0xD8  | Power, unit W, 6-digit format DDDD.DD         |
| 0xC4  | Address match, 2-digit                      |
| 0xB7  | Relay type: 0 = normally open, 1 = normally closed |
| 0xD5  | Number of data records                        |
| 0xF1  | Data logging toggle: 0 = on, 1 = off          |
| 0xF8  | Data logging interval: 2-digit, value = interval - 1 |

### Data Object Parsing Logic (`strToObj`)

Parsing is done from right to left. The first byte is the field, and subsequent bytes that can be directly parsed as decimal digits represent the value.

## Command Format

When sending data, there are some special rules. Below is a pseudo-code representation:

```text
writeDataValue = data
if writeDataValue == 0x9AA9
	send(0xBB9AA90CEE)
else
	if writeDataValue == 'AR' or 'AD'
		send(strToArrayBuffer(writeDataValue))
	else
		if writeDataValue contains 'b9', 'b8', 'f4', 'f6', 'f2', 'e1'
			send(0xBB + data + 0x0CEE)
		else
			send(checkAdd(writeDataValue))
```

Clearly, there are two special commands: `AR` and `AD`, which are not in HEX format. These appear to be used during firmware upgrades and will not be analyzed at this time.

### `checkAdd` Pseudo-code

```text
checkAdd(data)
	payload = 0xBB + data
	checksum = 0
	for b in payload
		checksum += b
	if password
		checksum = checksumWithPassword(checksum + password)
	else
		checksum = checksum[-1:]
	return payload + checksum + 0xEE
```

Based on the magic numbers and the implementation of `checkAdd`, it can be determined that the last byte of the packet is a checksum. However, experimental testing shows that when no password is used, this byte is always `0x0C`.

## Command Reference

| Command                                          | Meaning                                  |
|------------------------------------------------|------------------------------------------|
| 0x9AE0                                         | Start data loading                       |
| 0x9AA9                                         | Request data object                      |
| 0x9AF6                                         | Unknown, used for password interaction   |
| 0x9AF9 + byte + 0xF9                           | Set low battery alert percentage         |
| 0x00A5                                         | Factory reset                            |
| 0x00A6                                         | Reboot device                            |
| 0x9AC100A4                                     | CurrentClear                             |
| 0x9AC4 + byte + C4                             | Set communication address                |
| 0x9AC3 + byte + C3                             | Tpton                                    |
| 0x9AC2 + byte + C2                             | Tptoff                                   |
| 0x9AE9 + byte + E9                             | Min, byte = actual value * 10            |
| 0x9AE7 + byte + E7                             | LossVoltage, byte = actual value * 100   |
| 0x9AE8 + byte + E8                             | FullCurrent, byte = actual value truncated (tentative) |
| 0x9AE6 + byte + E6                             | FullVoltage, byte = actual value * 100   |
| 0x9AB7 + byte + B7                             | Relay type, byte = 00 or 01              |
| 0x9AE3 + byte + E3                             | LTP, complex calculation logic (see below) |
| 0x9AB1 + byte + B1                             | ETP, complex calculation logic (see below) |
| 0x9AC9 + byte + C9                             | OPP, byte = actual value * 100           |
| 0x9AC8 + byte + C8                             | NCP, byte = actual value * 100           |
| 0x9AC7 + byte + C7                             | OCP, byte = actual value * 100           |
| 0x9AC6 + byte + C6                             | LVP, byte = actual value * 100           |
| 0x9AC5 + byte + C5                             | OVP, byte = actual value * 100           |
| 0x9AF1 + byte + F1                             | Data logging toggle: 00 = on, 01 = off   |
| 0x9AF8 + byte + F8                             | Clear data logs, logic to be analyzed    |
| bytes(yymmdd) + 0xF2 + bytes(hhiiss) + 0xF39AF29AF3 | Set date and time                      |
| 0x9AD2 + byte + D2                             | MBFree, logic to be analyzed             |
| 0x9AB0 + byte + 0xB0                           | Set battery capacity, byte = value * 10 (max 9999) |
| 0x9AE39AB19AF70255E30255B1 + byte + F7 + ...   | Set temperature unit, logic to be analyzed |
| 0x9AD99AB4 + byte + B4                         | Set temperature (tentative)              |
| 0x9AC09AB2 + byte + B2                         | VoltageAlign                             |
| 0x9AC19AB3 + byte + B3                         | CurrentAlign                             |

### LTP/ETP Calculation Logic

The calculation logic for LTP and ETP involves a more complex encoding or transformation of the byte value. Further reverse engineering or experimentation is required to determine the exact algorithm. This will be updated once more information becomes available.